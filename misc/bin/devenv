#!/usr/bin/env python3
# -*- mode: python -*-

"""
This is a module docstring

TODO:

core_pattern
core_%e

"""

import sys
import os
import subprocess
import locale
import re
import multiprocessing

g_tld = os.path.expanduser("~/devenv")
g_srcdir = os.path.join(g_tld, "sources")
g_sysroot = os.path.join(g_tld, "sysroot")
g_num_cpus = multiprocessing.cpu_count()

# xxx This is dodgy... What about distcc environments?
# The idea is to never cripple my laptop with build jobs.
# Currently it seems too conservative
if g_num_cpus > 10:
    g_num_background_cpus = int(g_num_cpus / 2)
elif g_num_cpus > 2:
    g_num_background_cpus = int(g_num_cpus / 4) + 1
else:
    g_num_background_cpus = 1
g_num_background_cpus = 40

def bye(code=1):
    print("bye!")
    sys.exit(code)

def usage():
    print("\nDeveloper environment script")
    print("=======================")
    print("available subcommands:")


def run_process_and_return_output(args, trim=False, cwd=None):
    try:
        completed_process = subprocess.run(args,
                                           stdout=subprocess.PIPE,
                                           stderr=subprocess.STDOUT,
                                           check=True,
                                           cwd=cwd,
                                           encoding=locale.getpreferredencoding())
    except subprocess.CalledProcessError as ex:
        print("ERROR(process): Command failed|\n>>>| " + ' '.join(ex.cmd))
        print("ERROR(process): Output|\n>>>|", end='')
        print(ex.output.replace("\n", "\n>>>| "))
        bye()

    if trim:
        return completed_process.stdout.strip()
    else:
        return completed_process.stdout

def save_log(pid, category, output):
    print(f"NotImplemented:saving {output} for {pid}")

TOOLCHAIN=["env", "CXX=/usr/lib/icecc/bin/clang++","CC=/usr/lib/icecc/bin/clang",f"LD_LIBRARY_PATH={os.path.join(g_sysroot, 'lib')}:$LD_LIBRARY_PATH"]

def build_z3():
    srcdir=os.path.join(g_srcdir, "z3")
    builddir=os.path.join(srcdir, "build")
    srcurl = 'https://github.com/Z3Prover/z3.git'
    project_id = "z3"
    revision = run_process_and_return_output(["git", "-C", srcdir, "rev-parse", "master"], trim=True)

    if not os.path.exists(srcdir):
        subprocess.check_output(["git", "clone", srcurl, srcdir])

    build_output = run_process_and_return_output(
                                                 TOOLCHAIN +
                                                 [ "cmake",
                                                 "-Wno-dev",
                                                  "-S", srcdir,
                                                  "-B", builddir,
                                                  "-G", "Ninja",
                                                  f"-DCMAKE_INSTALL_PREFIX={g_sysroot}",
                                                  "-DCMAKE_BUILD_TYPE=Release",
                                                  "-DCMAKE_PREFIX_PATH=" + g_sysroot])


    save_log(project_id, "configure", build_output)

    build_output = run_process_and_return_output(TOOLCHAIN + [ "ninja", "-C", builddir, "-l", str(g_num_background_cpus)])
    save_log(project_id, "build", build_output)

    build_output = run_process_and_return_output(TOOLCHAIN + ["ninja", "-C", builddir, "-l", str(g_num_background_cpus), "install"])
    save_log(project_id, "install", build_output)
    build_output = run_process_and_return_output(["ostree", "--repo=" + g_sysroot, "commit",  "--branch=master", "-s", project_id, f"--add-metadata=version=\"{revision}\""], cwd=g_sysroot)


def build_llvm():
    srcdir=os.path.join(g_srcdir, "llvm-project", "llvm")
    builddir=os.path.join(g_srcdir, "llvm-project", "build")
    project_id = "llvm"
    revision = run_process_and_return_output(["git", "-C", srcdir, "rev-parse", "master"], trim=True)

    build_output = run_process_and_return_output(["env"] +
                                                 TOOLCHAIN +
                                                  ["cmake",
                                                  "-S", srcdir,
                                                  "-B", builddir,
                                                  "-G", "Ninja",
                                                  f"-DCMAKE_INSTALL_PREFIX={g_sysroot}",
                                                  "-DCMAKE_BUILD_TYPE=Release",
                                                  "-DCMAKE_PREFIX_PATH=" + g_sysroot,
                                                  "-DLLVM_ENABLE_PROJECTS=clang;clang-tools-extra;libcxx;libcxxabi;libunwind;lldb;compiler-rt;lld;polly;openmp;libc;libclc",
                                                  "-DLLVM_TARGETS_TO_BUILD=X86"])
    save_log(project_id, "configure", build_output)

    build_output = run_process_and_return_output(TOOLCHAIN + ["ninja", "-C", builddir, "-l", str(g_num_background_cpus)])
    save_log(project_id, "build", build_output)

    build_output = run_process_and_return_output(TOOLCHAIN + ["ninja", "-C", builddir, "-l", str(g_num_background_cpus), "install"])
    save_log(project_id, "install", build_output)

    build_output = run_process_and_return_output(["ostree", "--repo=" + g_sysroot, "commit",  "--branch=master", "-s", project_id, f"--add-metadata=version=\"{revision}\""], cwd=g_sysroot)


def run():
    if len(sys.argv) == 1:
        usage()
        bye()

    if not os.path.exists(g_srcdir):
        os.makedirs(g_srcdir)
    if not os.path.exists(g_sysroot):
        subprocess.check_output(["ostree", "--repo=" + g_sysroot, "init"])

    try:
        for task in sys.argv[1:]:
            globals()[task]()
    except KeyError:
        usage()


if __name__ == '__main__':
    run()
